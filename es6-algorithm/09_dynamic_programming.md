## 动态规划的公式
把动态规划 编程一个二维数组
每一行代表一个商品, 每一列代表数量 可以是包大小或者天数


`cell[行][列] = 比较后两者中的大值`, 贪婪嘛

1. 上一个单元格的值, cell[行-1][列]
2. 当前商品的值 + 剩余空间的价值(cell[行-1][列-当前商品占的数量])

## 举例
小偷偷东西最大化
* `吉他-G`: 1磅, $1500
* `音响-S`: 4磅, $3000
* `电脑-L`: 3磅, $2000
* `iPhone-I`: 1磅, $2000


| 商品/包容量 | 1 | 2 | 3 | 4 |
| --- | --- | --- |
| 吉他 | 1500-G | 1500-G | 1500-G | 1500-G |
| 音响 | 1500-G | 1500-G | 1500-G | 3000-S |
| 电脑 | 1500-G | 1500-G | 2000-L | 3500-L+G |
| iPhone | 2000-I | 3500-I+G | 3500-I+G | 4000-I+L |


* 电脑行 3磅列的时候,上个单元格是 1500-G, 当前商品是2000然后没有剩余空间, 那么填 2000-L
* 电脑行 4磅列的时候,上个单元格是 3000-S, 当前商品是2000剩余1磅, 1磅最多能放音响行,1磅列的东西. 结果就是2000-L+1500-G = 3500-L+G
* * iPhone 2磅列, 上个单元格是 1500-G, 当前商品2000剩余1磅, 1磅最多能放电脑行1磅列的1500-G的东西,结果就是2000-I+1500-G = 3500-I+G
* iPhone 4磅列, 上个单元格是 3500-L+G, 当前商品2000剩余3磅, 3磅最多能放电脑行3磅列的2000-L的东西,结果就是2000-I+2000-L = 3500-L+G
* 可选择的商品是约来越多的, 我们只能相信上一行的计算结果([行-1]).然后找到被约束的那一列
* 就算改变了商品的选择顺序, 最终结果也是一样的.


```js
if (word_a[i] === word_b[j]) {
  // The letters match
  cell[i][j] = cell[i - 1][j - 1] + 1;
} else {
  // The letters don't match
  cell[i][j] = Math.max(cell[i - 1][j], cell[i][j - 1]);
}
```